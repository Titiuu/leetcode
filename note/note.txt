53
使用了动态规划，以i结尾的最大和子序列为f[i]，则f[i+1] = max(f[i] + nums[i+1], nums[i+1])
1984
要想最小化选择的 k 名学生中最高分和最低分的差值，一定是在排好序后的数组中连续地进行选择
1020
深度优先搜索，对于每个边界的格子进行DFS，然后未被访问的格子就是飞地
688
通过题意可知，向每个方向前进的概率为 1/8，只要没有走出去都可以增加 1/8 成功的概率
把途径的 1/8 的概率相乘就是这一条路径的概率，然后求出所有可行路径的概率相加就是最终的概率。
509
斐波那契，简单dp
1137
同509题
70
爬楼梯包含的子问题：上面的台阶的走法由下面的决定
746
第 i 个台阶的当前最少费用由能到达它的台阶的最少费用决定
1791
每个结点对里必含有中心结点，任意两个结点对里必有相同结点
198
如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢？对于第 k~(k>2)间房屋，有两个选项：
偷窃第 k 间房屋，那么就不能偷窃第 k-1 间房屋，偷窃总金额为前 k-2 间房屋的最高总金额与第 kk 间房屋的金额之和。
不偷窃第 k 间房屋，偷窃总金额为前 k-1 间房屋的最高总金额。
969
由于次数不受限制，因此可每次查找到当前最大的数置于尾部，使用两次反转即可
717
0前面有偶数个1的时候才为true
55
贪心算法，维护当前最远位置
45
利用DP维护最少步数数组可完成，实际上可用贪心算法：对于下一步的落点选择能够到达更远距离的那一个
838
需处理的是R...L, R...R, R..., ...L, L...L
918
分两种情况：跨边界和不跨，不跨用最大和子序列，跨就用sum - 最小和子序列。全负的时候不可以考虑跨，因为会为0
1994
状态压缩DP，没时间搞；抄的官解
以下是我找到的一个解释的很清楚的题解
解题思路
因为1 <= nums[i] <= 30，这个范围非常小，我们可以直接计算。
1、先统计每个数出现的次数，记作count。
2、数字1比较特殊，它本身不能构成一个合法的subset，但是任意合法的subset加上任意个1，都仍然是合法的subset。
所以其它任何合法的subset个数都需要乘以1的子集个数，即power(2, count[1])。
3、明显不合法的数invalid = [4,8,9,12,16,18,20,24,25,27,28]。这些数本身就包含同一个质因子多次，所以可以直接删除。
4、所有质数primes = [2,3,5,7,11,13,17,19,23,29]。每种质数选择1个，都能够构成一个合法的subset。
那么总的subsets是多少呢？对于每个prime，可以不选它，也可以选count[prime]中的任意一个，所以有count[prime] + 1种方法。
总的subsets就是所有count[prime] + 1的乘积。但是本题中空集不是一个合法的subset，所以最后要减1，即不能所有prime都不选。
5、所有合数composites = [6,10,14,15,21,22,26,30]。分三种情况讨论：
    a、subset中包含一个composite，比如6。显然，选择了6以后，就不能再选择2和3。
    我们将count[2]和count[3]清零，然后计算只包含primes的subsets个数（注意此时可以包含空集），
    再在每个subset后面添加任意一个6，都能构成一个合法的subset。同样的方法可以计算其它合数的情况。
    b、subset中包含2个composites，只有6种情况：[15,14]、[15,22]、[15,26]、[21,10]、[21,22]、[21,26]，
    其它任意两个合数的组合都将导致质因子冲突。同样采用上面的方法计算每种情况的subsets。
    c、3个及以上的composites，这种情况不存在，任意3个composites都将导致质因子冲突。
以上就是所有情况了，计算每一个合法subsets并求和即可。
作者：wen-rou-yi-dao-123
链接：https://leetcode-cn.com/problems/the-number-of-good-subsets/solution/shu-ju-fan-wei-hen-xiao-shu-xue-fang-fa-uf2cn/
152
不能直接考虑以第 i 个数结尾的最大子数组积，因为当前是负数时，若前面为负数，则希望它尽可能小
所以可以考虑同时维护最大值和最小值，每次更新的最大值max和最小值min在当前数x，x*min，x*max中选择
1567
对于不含0的数组很容易想到算法，因此我们以0进行分段取最大值即可
917
保存所有字母反写即可
1024
维护以 i 为右边的数对的最大值
121
维护当前历史最低点，考虑当前卖出收益并使其最大化
122
由于买入卖出次数不受限制，因此可以直接吃到所有上涨的收益
1706
模拟即可
309
分为三种情况，第 i 天持有股票，未持有且处于冷冻期，未持有且不处于冷冻期
dp[i][0] = max(dp[i - 1][0], dp[i - 1][2] - prices[i]);
dp[i][1] = dp[i - 1][0] + prices[i];
dp[i][2] = max(dp[i - 1][1], dp[i - 1][2]);
714
DP，同上一题思路，把费用考虑进去即可
537
简单模拟题，懒得写代码了，抄的官解
139
我们定义 dp[i] 表示字符串 s 前 i 个字符组成的字符串 s[0..i−1] 是否能被拆分成若干个字典中出现的单词。
从前往后考虑转移方程，我们需要枚举 s[0..i−1] 中的分割点 j ，看 s[0..j−1] 组成的字符串s1（默认 j=0 时 s1为空串）
和s[j..i-1]组成的字符串s2是否都合法，如果两个字符串均合法，那么按照定义s1和s2拼接成的字符串也同样合法。
​是否合法可以直接由 dp[j]得知，剩下的我们只需要看s2是否合法即可，因此我们可以得出如下转移方程：
dp[i]=dp[j] && check(s[j..i−1])
其中check(s[j..i−1]) 表示子串s[j..i-1]是否出现在字典中。
258
模拟很容易做出来，但是官解的数学证明不容易想到
521
若其中一个较长则它本身就是特殊子序列
42
对于某个位置，其能够存的水为min(leftMax, rightMax) - presentHeight。一般思路是维护两个数组保存左右最大值。
对于这题可以利用双指针，减少空间复杂度。具体而言，在从左往右的过程中（反之同理）leftMax是完全可信的，而rightMax不可信。
但是如果leftMax < presentRightMax，则min(leftMax, rightMax) = leftMax，而不需要考虑rightMax。
217
哈希表记一下结束
