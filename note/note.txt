53
使用了动态规划，以i结尾的最大和子序列为f[i]，则f[i+1] = max(f[i] + nums[i+1], nums[i+1])
1984
要想最小化选择的 k 名学生中最高分和最低分的差值，一定是在排好序后的数组中连续地进行选择
1020
深度优先搜索，对于每个边界的格子进行DFS，然后未被访问的格子就是飞地
688
通过题意可知，向每个方向前进的概率为 1/8，只要没有走出去都可以增加 1/8 成功的概率
把途径的 1/8 的概率相乘就是这一条路径的概率，然后求出所有可行路径的概率相加就是最终的概率。
509
斐波那契，简单dp
1137
同509题
70
爬楼梯包含的子问题：上面的台阶的走法由下面的决定
746
第 i 个台阶的当前最少费用由能到达它的台阶的最少费用决定
1791
每个结点对里必含有中心结点，任意两个结点对里必有相同结点
198
如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢？对于第 k~(k>2)间房屋，有两个选项：
偷窃第 k 间房屋，那么就不能偷窃第 k-1 间房屋，偷窃总金额为前 k-2 间房屋的最高总金额与第 kk 间房屋的金额之和。
不偷窃第 k 间房屋，偷窃总金额为前 k-1 间房屋的最高总金额。
969
由于次数不受限制，因此可每次查找到当前最大的数置于尾部，使用两次反转即可
717
0前面有偶数个1的时候才为true
55
贪心算法，维护当前最远位置
45
利用DP维护最少步数数组可完成，实际上可用贪心算法：对于下一步的落点选择能够到达更远距离的那一个
838
需处理的是R...L, R...R, R..., ...L, L...L
918
分两种情况：跨边界和不跨，不跨用最大和子序列，跨就用sum - 最小和子序列。全负的时候不可以考虑跨，因为会为0
1994
状态压缩DP，没时间搞；抄的官解
以下是我找到的一个解释的很清楚的题解
解题思路
因为1 <= nums[i] <= 30，这个范围非常小，我们可以直接计算。
1、先统计每个数出现的次数，记作count。
2、数字1比较特殊，它本身不能构成一个合法的subset，但是任意合法的subset加上任意个1，都仍然是合法的subset。
所以其它任何合法的subset个数都需要乘以1的子集个数，即power(2, count[1])。
3、明显不合法的数invalid = [4,8,9,12,16,18,20,24,25,27,28]。这些数本身就包含同一个质因子多次，所以可以直接删除。
4、所有质数primes = [2,3,5,7,11,13,17,19,23,29]。每种质数选择1个，都能够构成一个合法的subset。
那么总的subsets是多少呢？对于每个prime，可以不选它，也可以选count[prime]中的任意一个，所以有count[prime] + 1种方法。
总的subsets就是所有count[prime] + 1的乘积。但是本题中空集不是一个合法的subset，所以最后要减1，即不能所有prime都不选。
5、所有合数composites = [6,10,14,15,21,22,26,30]。分三种情况讨论：
    a、subset中包含一个composite，比如6。显然，选择了6以后，就不能再选择2和3。
    我们将count[2]和count[3]清零，然后计算只包含primes的subsets个数（注意此时可以包含空集），
    再在每个subset后面添加任意一个6，都能构成一个合法的subset。同样的方法可以计算其它合数的情况。
    b、subset中包含2个composites，只有6种情况：[15,14]、[15,22]、[15,26]、[21,10]、[21,22]、[21,26]，
    其它任意两个合数的组合都将导致质因子冲突。同样采用上面的方法计算每种情况的subsets。
    c、3个及以上的composites，这种情况不存在，任意3个composites都将导致质因子冲突。
以上就是所有情况了，计算每一个合法subsets并求和即可。
作者：wen-rou-yi-dao-123
链接：https://leetcode-cn.com/problems/the-number-of-good-subsets/solution/shu-ju-fan-wei-hen-xiao-shu-xue-fang-fa-uf2cn/
152
不能直接考虑以第 i 个数结尾的最大子数组积，因为当前是负数时，若前面为负数，则希望它尽可能小
所以可以考虑同时维护最大值和最小值，每次更新的最大值max和最小值min在当前数x，x*min，x*max中选择
1567
对于不含0的数组很容易想到算法，因此我们以0进行分段取最大值即可
917
保存所有字母反写即可
1024
维护以 i 为右边的数对的最大值
121
维护当前历史最低点，考虑当前卖出收益并使其最大化
122
由于买入卖出次数不受限制，因此可以直接吃到所有上涨的收益
1706
模拟即可
309
分为三种情况，第 i 天持有股票，未持有且处于冷冻期，未持有且不处于冷冻期
dp[i][0] = max(dp[i - 1][0], dp[i - 1][2] - prices[i]);
dp[i][1] = dp[i - 1][0] + prices[i];
dp[i][2] = max(dp[i - 1][1], dp[i - 1][2]);
714
DP，同上一题思路，把费用考虑进去即可
537
简单模拟题，懒得写代码了，抄的官解
139
我们定义 dp[i] 表示字符串 s 前 i 个字符组成的字符串 s[0..i−1] 是否能被拆分成若干个字典中出现的单词。
从前往后考虑转移方程，我们需要枚举 s[0..i−1] 中的分割点 j ，看 s[0..j−1] 组成的字符串s1（默认 j=0 时 s1为空串）
和s[j..i-1]组成的字符串s2是否都合法，如果两个字符串均合法，那么按照定义s1和s2拼接成的字符串也同样合法。
​是否合法可以直接由 dp[j]得知，剩下的我们只需要看s2是否合法即可，因此我们可以得出如下转移方程：
dp[i]=dp[j] && check(s[j..i−1])
其中check(s[j..i−1]) 表示子串s[j..i-1]是否出现在字典中。
258
模拟很容易做出来，但是官解的数学证明不容易想到
521
若其中一个较长则它本身就是特殊子序列
42
对于某个位置，其能够存的水为min(leftMax, rightMax) - presentHeight。一般思路是维护两个数组保存左右最大值。
对于这题可以利用双指针，减少空间复杂度。具体而言，在从左往右的过程中（反之同理）leftMax是完全可信的，而rightMax不可信。
但是如果leftMax < presentRightMax，则min(leftMax, rightMax) = leftMax，而不需要考虑rightMax。
217
哈希表记一下结束
2100
预先记录一下每个位置的左边和右边的连续递减或递增的天数即可
413
考虑以当前位置结尾的序列个数，进行累加，由于当前个数只与之前一位的个数有关，因此可以用单变量代替以减少空间复杂度
504
简单模拟，注意处理0
2055
对于每一个询问，我们只需要找到给定区间内最左侧和最右侧的两个蜡烛，这样两个蜡烛之间的所有盘子都是符合条件的
前缀和用于计算数量
官解清晰简洁故搬运
798
不会，借鉴的官解下的bellyache的评论
他的这个思路很明了。
steps数组对应的是移动下标对应的步数之后，nums[i] = i 的数有多少，如 steps[2] = 2 表示移动两步正好与nums下标相等的有2个数
dp[i] = dp[i-1] - steps[i-1] + 1
dp表示移动 i 步对应的分数
96
1 2 5 14 42 132 429 1430 4862
  0 1 4 14 48 165
观察规律可得dp[i] = (4i-2)/(i+1) * dp[i-1] (dp[0]=1, dp[1]=2)
589
递归即可
2049
当把一个节点和与它相连的所有边删除，剩余部分最多为三棵非空子树
即原节点的左子树（如果有），右子树（如果有），以及把 以这个节点为根结点的子树 移除 所形成的子树(根节点除外)
通过DFS，记录每个结点的分数并更新
590
递归即可
393
对每个数字进行遍历，进行判断，消耗掉尾数（消耗不掉判断为假）；若结束后还有尾数也判断为假
599
简单题，暴力解或哈希
2044
对于每个数有两种情况，选择其进行或\不选择。因此可以进行暴力搜索所有情况。数据量小2^16
720
使用字典树这个数据结构解决。具体：将每个单词插入字典树之后，进行前缀搜索判断和更新最长答案
310
一开始写了一个遍历根节点深搜，超时；然后看题解找了一个很巧妙的想法：
我们从边缘开始，先找到所有出度为1的节点，然后把所有出度为1的节点进队列，然后不断地bfs，
最后找到的就是两边同时向中间靠近的节点，那么这个中间节点就相当于把整个距离二分了，那么它当然就是到两边距离最小的点啦，
也就是到其他叶子节点最近的节点了。
796
按题意做就行
429
BFS题，用队列即可
780
简单思路是：不停地用大的数减去小的数，然后中间判断是否得到初始数据。然而这样会超时，那么需要加速减去。
具体而言就是进行特殊费时情况的判断并使用取余代替
804
哈希表记录，返回哈希表大小
357
2 91
3 739
4 5275
5 32491
6 168571
7 712891
8 2345851
从数学的角度思考，一位数等于A(10,1)=10，两位数A(10,2)-A(9,1)+10=91，三位数A(10,3)-A(9,2)+91=739
A(10,i)-A(9,i)+dp[i-1]
806
遍历并累加即可
23
0 1 2 3 4 5 6 7 8   k = 9
9/2=4
归并法，每次分为两组进行两路合并直至合并为一组
50
79次方怎么算？ 1001111 
79...1      39...1      19...1       9...1       4...0       2...0     1...1
x           x^2         x^4          x^8                               x^64
总结：移位观察每一位的数据是否为1，同时不停平方，若为1则加上
380
一个朴素思路是使用hash表存储数据，这样可以做到插入和删除O(1)，随即返回部分只能暴力搜索
因此改进思路是用hash表存储数据的位置，然后用数组存储数据
24
p->f->s->t
temp = f
p->s temp->s->t
p->s temp->t
p->s->temp->t
p = temp
1672
遍历并累加即可
30
需要用到单词长度相等这个条件，否则会超时。具体而言，准备两个hash表，一个保存words里的单词个数，另一个
对每次遍历的固定总长度去统计单词长度的单词的个数。
过程中，若出现了第一个hash表内不存在的单词，或者是出现了超出第一个hash表中单词的个数的情况，则跳出当前循环。
若顺利统计结束，则说明两个hash表相等（因为串的长度相等）。
代码来自评论区
41
不会，看了官解一。属实太妙了。根据hash表的性质原地修改内部的值
385
题目都没怎么看懂，不过如果是处理字符串的话，括号匹配确实应该用栈
46
全排列可以看作是一个搜索问题，每次对所有数据进行搜索，如果已访问则跳过，未访问则加入队列。最后长度达到目标的时候返回队列
479
我以为暴力搜会超时。。。
47
全排列加去重，思路是先排序保证相同的数字相邻，然后对于连续访问同一个数字的情况进行修改，是这种情况直接跳过
6070
按要求模拟
6071
hash表存一下，然后判断一下并累加
819
预处理+计个数
386
模拟搜索，当未超过范围时应*10，当超过时应++，当末位到9时应该回退
48
找规律题，分奇偶讨论一下发现可以写出统一的式子。官解三翻转的思路很妙
821
直接找到目标字母然后双向遍历即可，向右遍历时用找到的新的目标字母更新
39
搜索题，为了去重，进行下一层搜索的时候，需要从当前结点的值开始搜索，而不能从头开始搜索
388
维护每层的当前前缀长度即可
824
按要求模拟即可
396
0 * n0 + 1 * n1 + 2 * n2 + …… + n-1 * nn-1
0 * nn-1 + 1 * n0 + 2 * n1 + …… + n-1 * nn-2
-> ans + sum - n-1 * nn-1
-> ans + sum - n * n(n-i)
6041
用set去重加排序
6042
不会，超时。。。其实方法对的，就对点遍历即可。区别在于是否是引用的遍历 auto&不用拷贝而auto要拷贝
6043
看错题了。。。
398
蓄水池抽样：
设nums中有k 个值为target 的元素，该算法会保证这k 个元素的下标成为最终返回值的概率均为1/k
883
俯视下为非0块的数量，正侧面为行或者列的最大值和，答案为官解
417
DFS, 从边缘反方向搜索。
905
双端队列一次遍历
427
简单递归，但是要注意函数中放在栈中的变量和类实例会被释放
1823
约瑟夫环，数学角度找规律即可
713
若[i,j]区间内的元素积小于k，那么[i+1,j]区间内的积也比k小；同理若[i-1,j]区间内的元素积大于k，那么[i-1,j+1]区间内的积也比k大。
因此我们可以枚举右边界，滑动左边界，当滑到比k小，将可能的答案累加，并将右边界右移一次，左边界不动重新观察是否比k小
933
队列模拟
942
首先生成一个递增数组
然后对于连续的D，翻转部分数组
944
简单题，略
01.05
先判长，后进行前向遍历和后向遍历
1022
递归即可，本题用了迭代。
473
回溯法，逆序可以减少不必要的搜索
450
递归搜索，如果目标节点大于当前节点值，则去右子树中删除；
如果目标节点小于当前节点值，则去左子树中删除；
如果目标节点就是当前节点，分为以下三种情况：
其无左子树：其右子树顶替其位置，删除了该节点；
其无右子树：其左子树顶替其位置，删除了该节点；
其左右子节点都有：其左子树转移到其右子树的最左节点的左子树上，然后右子树顶替其位置
829
差为1的等差数列求和，对范围内可能的k遍历，用求和公式的变形式验证
929
按逻辑模拟即可
478
有一个坑：在面积里随机取点不能是长度随机取点+角度随机取点。可以想象到如果半径随机取点经过旋转后越内圈的点越密集
因此可以在半径的平方内随机取点，之后开平方
732
记录不同时刻会议开始和结束数量，进行遍历即可
1037
dx1:dx2 == dy1:dy2 ==> dx1*dy2 == dx2*dy1
497
对所有矩形内的整数点进行编号，然后随机返回编号，并转换为整数点
1936
模拟即可
1003
对于连续的'abc'进行跳过处理，如果一次处理未改变当前状态则代表之后也不会改变则可以返回false，处理完返回true
730
不会，参考https://leetcode.cn/problems/count-different-palindromic-subsequences/solution/tong-ji-butong-by-jiang-hui-4-q5xf/
1935
设置标志并在遇到空格时重置
2293
简单模拟
2294
排序之后遍历，设置左右值标记用来判断是否需要划分。
926
枚举每个分割点，分割点前设置为000...，分割点后设置为111...
668
遍历超时，抄的官解。对于如何证明答案一定在乘法表中：（来自灵茶山艾府）
设 count(x) 表示乘法表中 <=x 的元素个数。
为什么最小的满足 count(x) >=k 的 x 一定在乘法表中？
注意到此时有 count(x-1) < k，那么 count(x) - count(x-1) > 0 ，也就是等于 x 的个数不为 0，也就是说 x 在乘法表中。
205
建立记录不同字母的前驱和后继的map，遍历字符处理冲突即可
890
调用205中的函数即可
1051
略
o29
找出所有需要插入值的情况
508
深搜+map
1108
略
515
广搜，每层更新最大值
1184
累加，并返回累加值和sum-累加值中更小的那个
919
广搜加返回最左元素（代码来自官解）
592
简单模拟，抄的官解
1331
先排序，表序号；再根据序号和数字的对应关系对初始数组遍历得到结果
1374
简单分类讨论题，用到两个字母即可
数组+前后指针
1403
排序，取大数求和
623
层序遍历
1408
排序之后从小到大搜索即可