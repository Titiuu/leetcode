53
使用了动态规划，以i结尾的最大和子序列为f[i]，则f[i+1] = max(f[i] + nums[i+1], nums[i+1])
1984
要想最小化选择的 k 名学生中最高分和最低分的差值，一定是在排好序后的数组中连续地进行选择
1020
深度优先搜索，对于每个边界的格子进行DFS，然后未被访问的格子就是飞地
688
通过题意可知，向每个方向前进的概率为 1/8，只要没有走出去都可以增加 1/8 成功的概率
把途径的 1/8 的概率相乘就是这一条路径的概率，然后求出所有可行路径的概率相加就是最终的概率。
509
斐波那契，简单dp
1137
同509题
70
爬楼梯包含的子问题：上面的台阶的走法由下面的决定
746
第 i 个台阶的当前最少费用由能到达它的台阶的最少费用决定
1791
每个结点对里必含有中心结点，任意两个结点对里必有相同结点
198
如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢？对于第 k~(k>2)间房屋，有两个选项：
偷窃第 k 间房屋，那么就不能偷窃第 k-1 间房屋，偷窃总金额为前 k-2 间房屋的最高总金额与第 kk 间房屋的金额之和。
不偷窃第 k 间房屋，偷窃总金额为前 k-1 间房屋的最高总金额。
969
由于次数不受限制，因此可每次查找到当前最大的数置于尾部，使用两次反转即可
717
0前面有偶数个1的时候才为true
55
贪心算法，维护当前最远位置
45
利用DP维护最少步数数组可完成，实际上可用贪心算法：对于下一步的落点选择能够到达更远距离的那一个
838
需处理的是R...L, R...R, R..., ...L, L...L
918
分两种情况：跨边界和不跨，不跨用最大和子序列，跨就用sum - 最小和子序列。全负的时候不可以考虑跨，因为会为0
1994
状态压缩DP，没时间搞；抄的官解
以下是我找到的一个解释的很清楚的题解
解题思路
因为1 <= nums[i] <= 30，这个范围非常小，我们可以直接计算。
1、先统计每个数出现的次数，记作count。
2、数字1比较特殊，它本身不能构成一个合法的subset，但是任意合法的subset加上任意个1，都仍然是合法的subset。
所以其它任何合法的subset个数都需要乘以1的子集个数，即power(2, count[1])。
3、明显不合法的数invalid = [4,8,9,12,16,18,20,24,25,27,28]。这些数本身就包含同一个质因子多次，所以可以直接删除。
4、所有质数primes = [2,3,5,7,11,13,17,19,23,29]。每种质数选择1个，都能够构成一个合法的subset。
那么总的subsets是多少呢？对于每个prime，可以不选它，也可以选count[prime]中的任意一个，所以有count[prime] + 1种方法。
总的subsets就是所有count[prime] + 1的乘积。但是本题中空集不是一个合法的subset，所以最后要减1，即不能所有prime都不选。
5、所有合数composites = [6,10,14,15,21,22,26,30]。分三种情况讨论：
    a、subset中包含一个composite，比如6。显然，选择了6以后，就不能再选择2和3。
    我们将count[2]和count[3]清零，然后计算只包含primes的subsets个数（注意此时可以包含空集），
    再在每个subset后面添加任意一个6，都能构成一个合法的subset。同样的方法可以计算其它合数的情况。
    b、subset中包含2个composites，只有6种情况：[15,14]、[15,22]、[15,26]、[21,10]、[21,22]、[21,26]，
    其它任意两个合数的组合都将导致质因子冲突。同样采用上面的方法计算每种情况的subsets。
    c、3个及以上的composites，这种情况不存在，任意3个composites都将导致质因子冲突。
以上就是所有情况了，计算每一个合法subsets并求和即可。
作者：wen-rou-yi-dao-123
链接：https://leetcode-cn.com/problems/the-number-of-good-subsets/solution/shu-ju-fan-wei-hen-xiao-shu-xue-fang-fa-uf2cn/
152
不能直接考虑以第 i 个数结尾的最大子数组积，因为当前是负数时，若前面为负数，则希望它尽可能小
所以可以考虑同时维护最大值和最小值，每次更新的最大值max和最小值min在当前数x，x*min，x*max中选择
1567
对于不含0的数组很容易想到算法，因此我们以0进行分段取最大值即可
917
保存所有字母反写即可